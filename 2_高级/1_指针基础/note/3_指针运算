1:取地址和指针运算符
	1:取地址运算符: & 是取地址运算符,为一元运算符,它返回操作数的内存地址
	2:指针运算符: * 为指针运算符(或称为间接访问运算符),也是一元运算符,返回指针
	  指向的存储单元的值
	3:取地址和指针运算符的关系:
		指针运算符(*)是取地址运算符(&)的反运算符


2:指针赋值运算
	1:指针赋值的形式: 指针变量1 = 指针变量2;
		1:将 指针变量2 中存放的地址赋值给 指针变量1
		2:指针赋值实际上是地址的复制
	2:左值和右值
		1:左值出现在等号的左边,代表一个存储单元,通常用一个变量表示
		2:右值出现在等号的右边或输出函数中,代表存储单元中的值
			*p = *p + 1;
			printf("%d\n", *p);
			等号左边的 *p 代表左值, 等号右边的 *p 和 printf 中的 *p 代表右值


3:数组名的概念
	1:一个数组存储在一块连续内存单元中,数组名就是这块连续内存单元的首地址,也就是
	  数组中第一个元素的地址
	2:对数组的首地址加上偏移量就可以得到其他元素的地址
	3:数组名是一个常量,不允许重新赋值
		int a[5]={1,2,3,4,5};
		int b[5]={5,6,7,8,9};
		a = b;	// error


4:指针加减运算
	1:指针每递增一次,它都会指向下一个元素的存储单元
	2:指针每递减一次,它都会指向前一个元素的存储单元
	3:指针的增减时跳跃的字节数取决于指针所指向变量的数据类型的长度
		++p_var 或 p_var++				指向 var 后面的下一个元素
		--p_var 或 p_var--				指向 var 前面的元素
		p_var + i						指向 var 后面的第 i 个元素
		p_var - i						指向 var 前面的第 i 个元素
		++(*p_var) 或 (*p_var)++		将 var 的值加 1
		*(p_var++) 或 *p_var++			取出当前 var 的值,并将 p_var 加 1


5:指针比较运算
	1:前提是两个指针都指向同一个数组的元素,否则指向两个不同内存区域的指针进行
	  比较没有意义
		
		操作				意义
		p_a < p_b			如果 a 存储在 b 的前面,则返回 true
		p_a <= p_b			如果 a 存储在 b 的前面,或两个指针指向同一位置则 true
		p_a == p_b			如果指针指向同一位置则返回 true
		p_a != p_b			如果两指针指向不同的位置则返回 true
		p_a == NULL			如果 p_a 是空值则返回 true
