1:不可靠信号问题(一)
	1:发生信号时关联动作被重置为默认设置
		1:信号可能丢失
		2:程序片段
			1:在进程 sig_int 与再次调用 signal 之间发生的SIGINT 信号将不会被捕获
			2:导致进程终止
			void sig_int(int signo);
			...
			signal(SIGINT, sig_int);
			...
			void sig_int(int signo){
				signal(SIGINT, sig_int);
			}
	2:处理信号时,内核创建两个数据结构体: 信号屏蔽字(mask), 信号未决字(pending)
	3:Linux 中的信号模型是可靠的
		1:系统层面是可靠的
		2:用户层面是可靠的


2:不可靠信号问题(二)
	1:无法暂停阻塞信号
		1:只能忽略信号
		2:信号可能被丢失
		3:程序片段
			检测 sig_int_flag 变量和调用 pause 函数之间有个时间窗口
			如果在该时间窗口内发生 SIGINT 信号?
			void sig_int(int signo);
			...
			signal(SIGINT, sig_int);
			...
			while(sig_int_flag == 0)
				pause();
			...
			void sig_int(int signo){
				signal(SIGINT, sig_int);
				...
					sig_int_flag = 1;
			}
	2:将依赖于信号而执行的代码放置到信号处理函数中执行, 这时可靠的,否则这些代码
	  不会被执行


3:中断的系统调用
	1:进程调用"慢"系统调用时,如果发生了信号,内核会重启系统调用
	2:慢系统调用
		1:可能会永远阻塞的系统调用
		2:从终端设备,管道或网络设备上的文件读取
		3:向上述文件写入
		4:某些设备的文件打开
		5:pause 和 wait 系统调用
		6:一些设备的 ioctl 操作
		7:一些进程间通信函数
	3:快系统调用,标准库函数(标准IO函数)的信号中断是从中断点继续运行,而不是重启函
	  数


4:函数的可重入性
	1:在调用某个函数过程中出现信号,且该信号处理函数中再次调用此函数
	2:访问全局或静态变量的函数是不可重入函数
	3:程序片段
		(可重入函数)
		int double(int a){
			return a*2;
		}
		(不可重入函数)
		void foo(){
			static int intarray[28];
			static int index;
			if(index > 19)	return;
			intarray[index] = 9;
			index++;
		}
	4:前后数据不一致,函数是不可重入的(函数中使用全局变量或静态变量),不可重入函数
	  前后数据保持一致,函数是可重入的(函数中使用局部变量),可重入函数
	5:标准IO函数, 标志库函数, malloc, calloc, relloc 等函数是不可重入函数,
	  尽量不要在信号处理函数中使用. 
	6:在信号处理函数中,尽量不要调用不可重入函数,可能引发一些不可预知的后果.


5:信号特点
	1:信号的发生是随机的,但信号在何种条件下发生是可预测的
	2:进程刚开始启动的时,所有信号的处理方式要么默认要么忽略. 忽略 SIGUSR1 和
	  SIGUSR2 两个信号, 其他都采用默认方式(大多数是终止进程)
	3:进程在调用 exec 函数后, 原有信号的捕捉函数失效
	4:子进程的诞生总是继承父进程的信号处理方式
	5:在系统层面上信号的发生是可靠的,在 Linux 中的可靠性只保证一次,进程在处理
	  信号期间若发生同类型的信号不会丢失(内核会保存),会被延迟处理,但同类型信号
	  的多次发生只会保留以此即被处理一次. 若不同类型的信号发生也会被内核保留直接
	  会被处理,处理完后再处理原有信号
	6:用户层面可靠性,依赖于信号而执行的用户代码防止在信号处理程序内部执行是可靠
	  的,否则不一定可靠
	7:在信号发生时,系统调用可以被中断并在信号处理后系统调用会被重启
	8:在信号发生时,用户函数可以被中断但不能被重启,沿着中断点继续执行(在用户函数
	  中要保证数据一致性,即可重入性,不要访问全局变量和静态变量,堆中的变量若在
	  用户函数内部分配没有关系,否则会出现不可重入性)


6:信号集和信号屏蔽函数
	1:信号集函数
		信号集为一个或多个信号的集合,主要用在信号屏蔽函数中
		#include <signal.h>
		int sigemptyset(sigset_t *set);
		功能: set 为信号集,将信号集清空, 对应将所有信号屏蔽字置0
		int sigfillset(sigset_t *set);
		功能: 所有信号加入到信号集中, 对应将所有信号屏蔽字置1
		int sigaddset(sigset_t *set, int signo);
		功能: 将某个信号加入到信号集中, 对应将信号屏蔽字某位置1
		int sigdelset(sigset_t *set, int signo);
		功能: 将某个信号从信号集中删除, 对应将信号屏蔽字某位置0
		上述函数返回: 若成功返回0, 出错返回-1
		int sigismember(const sigset_t *set, int signo);
		功能: 测试信号集中是否包含某个信号, 对应判断信号屏蔽字某位是否置1.		
		返回: 真返回1, 假返回0, 出错返回-1;
	2:信号屏蔽函数
		#include <signal.h>
		int sigprocmask(int how, const sigset_t *restrict set, 
				sigset_t *restrict oset);
		功能: 利用 set 去覆盖内核中信号屏蔽字,oset 存放原有的信号屏蔽字
		返回: 成功返回0,出错返回-1
		int sigpending(sigset_t *set);
		功能: 获取信号未决字内容
		返回: 成功返回0, 出错返回-1
		参数 how
			SIG_BLOCK: 利用 set 中信号设置信号屏蔽字
			SIG_UNBLOCK: 利用 set 中信号不设置信号屏蔽字
			SIG_SETMASK: 利用 set 中信号区替换内核信号屏蔽字
		>进程可以暂时屏蔽信号,使得进程在执行过程中发生的相应信号暂时被阻塞,等待
		进程解除信号屏蔽后再由内核或驱动将该信号递送给进程
		>信号屏蔽可屏蔽程序执行过程中的中断
	3:信号屏蔽设置
		1:信号在处理过程中是被屏蔽的(被置1)处理完毕解除屏蔽(被置0),可在函数可重
		  入性中使用信号屏蔽计数
		2:内核中的 task_struct 中包含来两个32位字(记录相关的信号信息),分别是
		  信号屏蔽字mask, 信号未决字pending
			mask: 共有31位(代表1-31号信号,0号没有意义),每一位代表一个信号,初始为
				  0,若这位上发生信号会被立即处理,若为1(设置1则信号被屏蔽,设置0则
				  信号不被屏蔽),则在该位上发生信号不会被处理,会延迟处理
			pending: 初始为0,若mask 中某一位为1,但由发生了同样的信号,则在pending
					 同样的位置被置为1,以让进程知道该进程又发生过而进行延迟处理
		3:若干个信号一起设置为0或1称为信号集
		4:子进程继承父进程的信号屏蔽字,而不继承信号未决字
	4:sigprocmask 操作信号屏蔽原理
		SIG_BLOCK:
			*oset = mask;		// mask 为原先内核中的信号屏蔽字
			mask |= *set;
		SIG_UNBLOCK:
			*oset = mask;
			mask &= ~(*set);
		SIG_SETMASK:
			*oset = mask;
			mask = *set;

示例:
	signal_rel1.c								// 不可靠信号问题(一)
	signal_rel2.c								// 不可靠信号问题(二)
	signal_syscal.c								// 中断的系统调用
	signal_usercall.c							// 自定义用户函数被中断可重启
	signal_reentry.c							// 函数的可重入性
	signal_mask.c								// 信号集函数使用
	signal_pending.c
