1:查看进程状态
	1:命令
		ps aux
		ps -ef
	2:字段
		USER		进程的属主
		PID			进程的ID
		PPID		父进程
		%CPU		进程占用的CPU百分比
		%MEM		占用内存的百分比
		NI			进程的 NICE 值, 数值越大,表示较少占用 CPU 时间
		VSZ			进程虚拟大小
		RSS			驻留中页的数量
		TTY			终端 ID
		WCHAN		正在等待的进程资源
		START		启动进程的时间
		TIME		进程消耗 CPU 的时间
		COMMAND		命令的名称和参数
2:进程常见状态
	1:运行状态
		系统当前进程
		就绪状态进程
		ps 命令的 STAT 列为值 R
	2:等待状态
		等待事件发生
		等待系统资源
		ps 命令的 STAT 列为值 S
		可中断等待,(不可终端等待D)
	3:停止状态
		ps 命令的 STAT 列为值 T
	4:僵尸状态
		进程终止结束
		在进程表项中仍由记录
		ps 命令的 STAT 列为值 Z


3:进程调度
	第一步: 处理内核中的工作
	第二步: 处理当前进程
	第三步: 选择进程
		实时进程
		普通进程
	第四步: 进程交换
4:task_struct 中的调度信息
	1:策略:
		轮流策略
		先进显出策略
	2:优先权
		Jiffies 变量
	3:实时优先权
		实时进程之间
	4:计数器
5:进程状态变化关系
	停止态 --> 就绪态 --> 运行态 --> 僵死态
	不可中断等待态 --> 就绪态 --> 运行态 --> 僵死态
	可中断等待态 --> 就绪态 --> 运行态 --> 僵死态


6:进程标识
	#include <unistd.h>
	#include <sys/types.h>
	pid_t getpid(void)				获取当前进程ID
	uid_t getuid(void)				获得当前进程的实际用户ID
	uid_t geteuid(void)				获得当前进程的有效用户ID
	gid_t getgid(void)				获得当前进程的用户组ID
	pid_t getppid(void)				获得当前进程的父进程ID
	pid_t getpgrp(void)				获得当前进程所在的进程组ID
	pid_t getpgid(pid_t pid)		获得进程ID为 pid 的进程所在的进程组ID


7:进程创建
	#include <sys/types.h>
	#include <unistd.h>
	pid_t fork(void);
	返回: 子进程中为0,父进程中为子进程ID,出错-1
	pid_t vfork(void);
	返回: 子进程中为0,父进程中为子进程ID,出错-1
	1:fork 创建的新进程被称为子进程,该函数被调用以此,但返回两次,两次返回的区别
	  是: 在子进程中的返回值是0,而在父进程中的返回值则是新子进程的进程ID.
	2:创建子进程,父子进程哪个先运行根据系统调度且复制父进程的内存空间
	3:vfork 创建子进程,但子进程先运行且不复制父进程的内存空间
	4:子进程的继承属性
		用户信息和权限,目录信息,信号信息,环境,共享存储段,资源限制,堆,栈和数据段
		共享代码段
	5:子进程特有信息
		进程 ID, 锁信息, 运行时间, 未决信号
	6:操作文件时的内核结构变化
		1:子进程只继承父进程的文件描述符, 不继承但共享文件表项和 i-node.
		2:父进程创建一个子进程后,文件表项中的引用计数器加1变成2,当父进程 close
		  操作后,计数器减1, 子进程还是可以使用文件表项,只有当计数器为0时才会
		  释放文件表项


8:守护进程,孤儿进程,僵尸进程
	1:守护进程
		1:守护进程(daemon)是生存期长的一种进程,它们常常在系统引导装入时启动,
		  在系统关闭时终止
		2:所有守护进程都以超级用户的优先权运行
		3:守护进程没有控制终端
		4:守护进程的父进程都是 init 进程
	2:孤儿进程
		1:父进程结束,子进程就称为孤儿进程,会由1号进程(init进程)领养
	3:僵尸进程
		1:子进程结束但没有完全释放内存(在内核中的 task_struct 没有释放), 该进程
		  就成为僵尸进程
		2:当僵尸进程的父进程结束后就会被 init 进程领养,最终被回收
		3:避免僵尸进程
			1:让僵尸进程的父进程来回收,父进程每隔一段时间来查询子进程是否结束并
			  回收调用 wait() 或者 waitpid(), 通知内核释放僵尸进程.
			2:采用信号 SIGCHLD 通知处理,并在信号处理程序中调用 wait 函数.
			3:让僵尸进程称为孤儿进程,由 init 进程回收


9:进程状态


示例
	process_id.c
	process_fork.c					// fork 的使用
	process_fork2.c					// 父进程和子进程的运行顺序
	process_fork3.c					// 子进程的继承
	process_fork4.c					// 父子进程以操作文件
	process_append.c				// 案例: 父进程调节偏移量,子进程追加内容
		// 子进程值继承父进程的文件描述符表,不继承但共享文件表项和i-node
	process_link.c					// 创建进程链
	process_fan.c					// 创建进程扇
	process_orphen.c				// 创建孤儿进程
	process_zombie.c				// 创建僵尸进程
