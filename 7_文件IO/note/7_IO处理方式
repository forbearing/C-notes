1:IO处理的五种模型
	1:阻塞IO模型
		若所调用的IO函数没有完成相关的功能就会使进程挂起,直到相关数据到达才会
		返回. 如:终端,网络设备的访问
	2:非阻塞模型
		当请求的IO操作不能完成时,则不让进程休眠,而且返回一个错误.
		如: open, read, write 访问
	3:IO多路转接模型
		如果请求的IO操作阻塞,且他不是真正阻塞IO,而且让其中的一个函数等待,在这
		期间,IO还能进行其他操作. 如: select 函数
	4:信号驱动IO模型
		在这种模型下,通过安装一个信号处理程序,系统可以自动捕获特定信号的到来,
		从而启动 I/O
	5:异步IO模型
		在这种模型下,当一个描述符已准备好,可以启动IO时,进程会通知内核. 由内核
		进行后续处理, 这种用法现在较少


2:非阻塞IO
	1:低速系统调用时,进程可能会阻塞
	2:非阻塞IO确定操作(read, open, write) 不阻塞, 如果操作不能完成,则出错返回
	3:设定非阻塞的方式
		1:使用open 打开文件, 设置 O_NONBLOCK 标志
		2:如果一个文件已经打开,则使用 fcntl 修改文件状态标志


示例:
	nonblock_read.c						// 非阻塞从键盘读取信息
